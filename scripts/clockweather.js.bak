// Clock & Weather version 1.3.1 Build 017
// Fixed: Wind direction now shows as N, NE, E, SE etc instead of arrows
// Fixed: FXMaster API integration

console.log("Clock & Weather | Script loaded");

class ClockWeatherApp extends Application {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "clockweather-app",
      title: game.i18n.localize("CLOCKWEATHER.Title"),
      template: "modules/clockweather/templates/clockweather.html",
      width: 500,
      height: "auto",
      resizable: true,
      classes: ["clockweather"]
    });
  }

  getData() {
    const data = super.getData();
    const currentDateTime = this.getCurrentDateTime();
    const shiftNumber = this.calculateShiftNumber(currentDateTime.time);
    const shiftName = this.getShiftName(shiftNumber);
    const weatherData = this.getWeatherForDateAndShift(currentDateTime.date, shiftNumber);
    const altitude = game.settings.get("clockweather", "altitude");

    return {
      ...data,
      date: currentDateTime.date,
      time: currentDateTime.time,
      shift: shiftName,
      shiftNumber: shiftNumber,
      weather: weatherData,
      altitude: altitude,
      isGM: game.user.isGM,
      fxMasterEnabled: game.modules.get("fxmaster")?.active
    };
  }

  getCurrentDateTime() {
    const saved = game.settings.get("clockweather", "currentDateTime");
    if (saved && saved.date && saved.time) {
      return saved;
    }
    
    const weatherData = this.getWeatherData();
    const firstDate = Object.keys(weatherData)[0] || "2014-06-14";
    return {
      date: firstDate,
      time: "00:00"
    };
  }

  calculateShiftNumber(time) {
    const [hours, minutes] = time.split(':').map(Number);
    const totalMinutes = hours * 60 + minutes;
    
    if (totalMinutes >= 0 && totalMinutes < 240) return 1;
    if (totalMinutes >= 240 && totalMinutes < 480) return 2;
    if (totalMinutes >= 480 && totalMinutes < 720) return 3;
    if (totalMinutes >= 720 && totalMinutes < 960) return 4;
    if (totalMinutes >= 960 && totalMinutes < 1200) return 5;
    return 6;
  }

  getShiftName(shiftNumber) {
    return game.i18n.localize(`CLOCKWEATHER.Shift${shiftNumber}`);
  }

  calculateShift(time) {
    const shiftNumber = this.calculateShiftNumber(time);
    return this.getShiftName(shiftNumber);
  }

  getWeatherData() {
    return game.settings.get("clockweather", "weatherData") || {};
  }

  getWeatherForDateAndShift(date, shiftNumber) {
    const weatherData = this.getWeatherData();
    const dayData = weatherData[date];
    
    if (!dayData || !dayData.shifts) {
      return {
        weatherCode: game.i18n.localize("CLOCKWEATHER.NoData"),
        windCode: "",
        windDirection: "",
        windDirectionLocalized: "",
        windspeed: 0,
        temp: 0,
        feelsLike: 0,
        visibility: 10000
      };
    }

    const shiftData = dayData.shifts.find(s => s.shift === shiftNumber);
    
    if (!shiftData) {
      return {
        weatherCode: game.i18n.localize("CLOCKWEATHER.NoData"),
        windCode: "",
        windDirection: "",
        windDirectionLocalized: "",
        windspeed: 0,
        temp: 0,
        feelsLike: 0,
        visibility: 10000
      };
    }

    const altitude = game.settings.get("clockweather", "altitude");
    const adjustedTemp = shiftData.temp - Math.round(altitude / 150);
    const feelsLike = this.calculateFeelsLike(adjustedTemp, shiftData.windspeed);
    const visibility = this.calculateVisibility(shiftData.weatherCode, shiftData.windspeed);
    const windDir = shiftData.windDirection || "N";
    
    return {
      weatherCode: game.i18n.localize(`CLOCKWEATHER.Weathertype.${shiftData.weatherCode}`) || shiftData.weatherCode,
      windCode: game.i18n.localize(`CLOCKWEATHER.Windtype.${shiftData.windCode}`) || shiftData.windCode,
      windDirection: windDir,
      windDirectionLocalized: game.i18n.localize(`CLOCKWEATHER.WindDir.${windDir}`) || windDir,
      windspeed: shiftData.windspeed,
      temp: adjustedTemp,
      feelsLike: feelsLike,
      visibility: visibility,
      visibilityText: this.getVisibilityText(visibility),
      rawWeatherCode: shiftData.weatherCode
    };
  }

  calculateVisibility(weatherCode, windspeed) {
    // Beräkna sikt i meter baserat på väderförhållanden
    let baseVisibility = 10000; // 10km i klart väder
    
    switch(weatherCode) {
      case "clear_sky":
      case "clear":
      case "fair":
        baseVisibility = 10000;
        break;
      case "partly_cloudy":
      case "cloudy":
        baseVisibility = 8000;
        break;
      case "overcast":
        baseVisibility = 6000;
        break;
      case "fog":
      case "mist":
        baseVisibility = 200;
        break;
      case "light_rain":
      case "light_snow":
        baseVisibility = 4000;
        break;
      case "rain":
      case "snow":
        baseVisibility = 1000;
        break;
      case "heavy_rain":
      case "heavy_snow":
      case "blizzard":
        baseVisibility = 200;
        break;
      case "thunderstorm":
        baseVisibility = 2000;
        break;
    }
    
    // Stark vind kan minska sikten ytterligare
    if (windspeed > 15) {
      baseVisibility = Math.min(baseVisibility, baseVisibility * 0.7);
    }
    
    return Math.round(baseVisibility);
  }

  getVisibilityText(visibility) {
    if (visibility >= 10000) return game.i18n.localize("CLOCKWEATHER.Visibility.Excellent");
    if (visibility >= 4000) return game.i18n.localize("CLOCKWEATHER.Visibility.Good");
    if (visibility >= 1000) return game.i18n.localize("CLOCKWEATHER.Visibility.Moderate");
    if (visibility >= 200) return game.i18n.localize("CLOCKWEATHER.Visibility.Poor");
    return game.i18n.localize("CLOCKWEATHER.Visibility.VeryPoor");
  }

  calculateFeelsLike(temp, windspeed) {
    // Vindkyleffekt (Wind Chill) - fungerar bäst under 10°C
    if (temp <= 10 && windspeed > 4.8) {
      const windKmh = windspeed * 3.6;
      const windChill = 13.12 + 0.6215 * temp - 11.37 * Math.pow(windKmh, 0.16) + 0.3965 * temp * Math.pow(windKmh, 0.16);
      return Math.round(windChill);
    }
    
    // Heat index för varmare väder (förenklad version)
    if (temp > 27 && windspeed < 3) {
      return Math.round(temp + 2);
    }
    
    // Lätt påverkan av vind vid måttliga temperaturer
    if (windspeed > 8) {
      return Math.round(temp - 1);
    }
    
    return Math.round(temp);
  }

  getWeatherForDate(date) {
    // Behåll för bakåtkompatibilitet
    const shiftNumber = this.calculateShiftNumber(this.getCurrentDateTime().time);
    return this.getWeatherForDateAndShift(date, shiftNumber);
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find('.time-advance').click(this._onAdvanceTime.bind(this));
    html.find('.save-datetime').click(this._onSaveDateTime.bind(this));
    html.find('.date-input').change(this._onDateChange.bind(this));
    html.find('.time-input').change(this._onTimeChange.bind(this));
    html.find('.altitude-slider').on('input', this._onAltitudeInput.bind(this));
    html.find('.altitude-slider').change(this._onAltitudeChange.bind(this));
    html.find('.post-to-chat').click(this._onPostToChat.bind(this));
    html.find('.toggle-fx').click(this._onToggleFX.bind(this));
  }

  async _onAdvanceTime(event) {
    event.preventDefault();
    const hours = parseInt(event.currentTarget.dataset.hours) || 0;
    
    const current = this.getCurrentDateTime();
    const [h, m] = current.time.split(':').map(Number);
    let newHours = h + hours;
    let newDate = current.date;

    if (newHours >= 24) {
      const date = new Date(current.date);
      date.setDate(date.getDate() + Math.floor(newHours / 24));
      newDate = date.toISOString().split('T')[0];
      newHours = newHours % 24;
    } else if (newHours < 0) {
      const date = new Date(current.date);
      date.setDate(date.getDate() - Math.ceil(Math.abs(newHours) / 24));
      newDate = date.toISOString().split('T')[0];
      newHours = ((newHours % 24) + 24) % 24;
    }

    const newTime = `${String(newHours).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
    
    await game.settings.set("clockweather", "currentDateTime", {
      date: newDate,
      time: newTime
    });

    this.updateAmbientLighting(newTime);
    
    // Uppdatera FXMaster om aktiverat
    if (game.settings.get("clockweather", "autoFXMaster")) {
      await this.updateFXMaster();
    }
    
    this.render();
  }

  async _onSaveDateTime(event) {
    event.preventDefault();
    ui.notifications.info(game.i18n.localize("CLOCKWEATHER.Saved"));
  }

  async _onDateChange(event) {
    const newDate = event.target.value;
    const current = this.getCurrentDateTime();
    
    await game.settings.set("clockweather", "currentDateTime", {
      date: newDate,
      time: current.time
    });
    
    if (game.settings.get("clockweather", "autoFXMaster")) {
      await this.updateFXMaster();
    }
    
    this.render();
  }

  async _onTimeChange(event) {
    const newTime = event.target.value;
    const current = this.getCurrentDateTime();
    
    await game.settings.set("clockweather", "currentDateTime", {
      date: current.date,
      time: newTime
    });
    
    this.updateAmbientLighting(newTime);
    
    if (game.settings.get("clockweather", "autoFXMaster")) {
      await this.updateFXMaster();
    }
    
    this.render();
  }

  _onAltitudeInput(event) {
    // Uppdatera visningen i realtid när slidern dras
    const newAltitude = parseInt(event.target.value) || 0;
    $(event.target).siblings('label').find('.altitude-value').text(`${newAltitude}m`);
  }

  async _onAltitudeChange(event) {
    const newAltitude = parseInt(event.target.value) || 0;
    await game.settings.set("clockweather", "altitude", newAltitude);
    this.render();
  }

  async _onToggleFX(event) {
    event.preventDefault();
    
    console.log("Clock & Weather | Toggle FX button clicked");
    console.log("Clock & Weather | FXMaster active?", game.modules.get("fxmaster")?.active);
    console.log("Clock & Weather | Ambient sound enabled?", game.settings.get("clockweather", "enableAmbientSound"));
    console.log("Clock & Weather | Auto FXMaster enabled?", game.settings.get("clockweather", "autoFXMaster"));
    
    if (!game.modules.get("fxmaster")?.active) {
      ui.notifications.warn(game.i18n.localize("CLOCKWEATHER.FXMasterNotActive"));
      return;
    }
    
    console.log("Clock & Weather | Toggling FXMaster effects...");
    await this.updateFXMaster();
    ui.notifications.info(game.i18n.localize("CLOCKWEATHER.FXMasterUpdated"));
  }

  async _onPostToChat(event) {
    event.preventDefault();
    
    const currentDateTime = this.getCurrentDateTime();
    const shiftNumber = this.calculateShiftNumber(currentDateTime.time);
    const shiftName = this.getShiftName(shiftNumber);
    const weatherData = this.getWeatherForDateAndShift(currentDateTime.date, shiftNumber);
    
    const chatContent = `
      <div class="clockweather-chat-message">
        <h3><i class="fas fa-cloud-sun"></i> ${game.i18n.localize("CLOCKWEATHER.Title")}</h3>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.Date")}:</strong> ${currentDateTime.date}</p>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.Time")}:</strong> ${currentDateTime.time}</p>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.CurrentShift")}:</strong> ${shiftName}</p>
        <hr>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.Conditions")}:</strong> ${weatherData.weatherCode}</p>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.Wind")}:</strong> ${weatherData.windCode} ${weatherData.windDirection} (${weatherData.windspeed} m/s)</p>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.Temperature")}:</strong> ${weatherData.temp}°C</p>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.FeelsLike")}:</strong> ${weatherData.feelsLike}°C</p>
        <p><strong>${game.i18n.localize("CLOCKWEATHER.Visibility")}:</strong> ${weatherData.visibilityText} (${weatherData.visibility}m)</p>
      </div>
    `;
    
    await ChatMessage.create({
      user: game.user.id,
      speaker: ChatMessage.getSpeaker(),
      content: chatContent,
      style: CONST.CHAT_MESSAGE_STYLES.OTHER
    });
    
    ui.notifications.info(game.i18n.localize("CLOCKWEATHER.PostedToChat"));
  }

  updateAmbientLighting(time) {
    if (!game.settings.get("clockweather", "controlAmbientLight")) return;
    if (!game.user.isGM) return;
    if (!canvas.scene) return;

    const [hours] = time.split(':').map(Number);
    
    let darkness = 0;
    
    if (hours >= 22 || hours < 4) {
      darkness = 1.0;
    } else if (hours >= 4 && hours < 6) {
      darkness = 0.7;
    } else if (hours >= 6 && hours < 18) {
      darkness = 0.0;
    } else if (hours >= 18 && hours < 22) {
      darkness = 0.5;
    }

    canvas.scene.update({ darkness: darkness });
  }

  async updateFXMaster() {
    console.log("Clock & Weather | === updateFXMaster START ===");
    console.log("Clock & Weather | FXMaster active?", game.modules.get("fxmaster")?.active);
    console.log("Clock & Weather | User is GM?", game.user.isGM);
    console.log("Clock & Weather | Canvas scene exists?", !!canvas.scene);
    
    if (!game.modules.get("fxmaster")?.active) {
      console.warn("Clock & Weather | FXMaster module is not active");
      return;
    }
    
    if (!game.user.isGM) {
      console.warn("Clock & Weather | Only GM can control FXMaster");
      return;
    }
    
    if (!canvas.scene) {
      console.warn("Clock & Weather | No active scene");
      return;
    }

    console.log("Clock & Weather | Updating FXMaster effects...");

    const currentDateTime = this.getCurrentDateTime();
    const shiftNumber = this.calculateShiftNumber(currentDateTime.time);
    const weatherData = this.getWeatherForDateAndShift(currentDateTime.date, shiftNumber);

    console.log("Clock & Weather | Current weather data:", weatherData);

    try {
      // Clear existing weather effects first
      console.log("Clock & Weather | Clearing existing ClockWeather effects...");
      
      // Remove previous ClockWeather particle effects by setting them to null/undefined
      // FXMaster doesn't understand type: "off", we need to actually remove the flag
      const existingEffects = ["clockweather-rain", "clockweather-snow", "clockweather-fog", 
                               "clockweather-lightning", "clockweather-leaves", "clockweather-dust"];
      
      for (const effectId of existingEffects) {
        console.log(`Clock & Weather | Removing effect flag: ${effectId}`);
        try {
          // Remove the effect by unsetting the flag completely
          await canvas.scene.unsetFlag("fxmaster", `effects.${effectId}`);
        } catch (e) {
          // Effect might not exist, that's OK
          console.log(`Clock & Weather | Effect ${effectId} didn't exist or couldn't be removed`);
        }
      }

      // Get weather effects to apply
      const effects = this.getWeatherEffects(weatherData);
      console.log("Clock & Weather | Effects to apply:", effects);

      // Apply new effects using FXMaster Hooks
      for (const effect of effects) {
        try {
          console.log(`Clock & Weather | Calling fxmaster.switchParticleEffect for ${effect.type}`);
          console.log(`Clock & Weather | Effect options:`, effect.options);
          
          Hooks.call("fxmaster.switchParticleEffect", {
            name: `clockweather-${effect.type}`,
            type: effect.type,
            options: effect.options
          });
          
          console.log(`Clock & Weather | ✓ Applied ${effect.type}`);
          
        } catch (error) {
          console.error(`Clock & Weather | Error applying effect ${effect.type}:`, error);
        }
      }

      // Handle ambient sounds and lights
      const ambientSoundEnabled = game.settings.get("clockweather", "enableAmbientSound");
      console.log("Clock & Weather | Ambient sound enabled?", ambientSoundEnabled);
      
      if (ambientSoundEnabled) {
        console.log("Clock & Weather | Updating ambient weather effects...");
        await this.updateAmbientWeatherEffects(weatherData);
      } else {
        console.log("Clock & Weather | Clearing ambient weather effects...");
        await this.clearAmbientWeatherEffects();
      }

      console.log("Clock & Weather | === updateFXMaster COMPLETE ===");
      
    } catch (error) {
      console.error("Clock & Weather | Error updating FXMaster:", error);
      ui.notifications.error(`FXMaster error: ${error.message}`);
    }
  }

  async updateAmbientWeatherEffects(weatherData) {
    if (!canvas.scene) return;
    
    const weatherCode = weatherData.rawWeatherCode || "";
    const windspeed = weatherData.windspeed;
    const environment = game.settings.get("clockweather", "soundEnvironment");
    
    // Clear existing weather effects first
    await this.clearAmbientWeatherEffects();
    
    // Don't add sounds for snow (it's silent)
    if (weatherCode.includes("snow")) {
      console.log("Clock & Weather | Snow weather - no ambient sounds");
      return;
    }
    
    // Determine sound file and if we need lights
    let soundFile = null;
    let needsLights = false;
    
    if (weatherCode.includes("thunder") || weatherCode.includes("typhoon")) {
      soundFile = "modules/clockweather/sounds/thunderstorm.ogg";
      needsLights = true;
    } else if (weatherCode.includes("heavy_rain")) {
      soundFile = "modules/clockweather/sounds/heavy_rain.ogg";
    } else if (weatherCode.includes("rain")) {
      soundFile = "modules/clockweather/sounds/rain.ogg";
    } else if (weatherCode.includes("sandstorm") || weatherCode.includes("dust")) {
      soundFile = "modules/clockweather/sounds/sandstorm.ogg";
    } else if (windspeed > 15) {
      soundFile = "modules/clockweather/sounds/strong_wind.ogg";
    }
    
    // At sea, override with wave sounds for stormy weather
    if (environment === "sea") {
      if (windspeed > 12 || weatherCode.includes("storm") || weatherCode.includes("typhoon")) {
        soundFile = "modules/clockweather/sounds/large_waves.ogg";
      } else if (!weatherCode.includes("sandstorm") && !weatherCode.includes("dust")) {
        soundFile = "modules/clockweather/sounds/waves.ogg";
      }
    }
    
    if (!soundFile) {
      console.log("Clock & Weather | No ambient sound needed for current weather");
      return;
    }
    
    console.log(`Clock & Weather | Creating ambient weather effects: ${soundFile}, lights: ${needsLights}`);
    
    // Calculate scene dimensions
    const sceneWidth = canvas.scene.dimensions.width;
    const sceneHeight = canvas.scene.dimensions.height;
    const centerX = sceneWidth / 2;
    const centerY = sceneHeight / 2;
    
    // Calculate radius to cover entire scene from center
    const radius = Math.sqrt(Math.pow(sceneWidth / 2, 2) + Math.pow(sceneHeight / 2, 2));
    
    if (needsLights) {
      // Create 3 lightning light sources spread across scene
      const lightPositions = [
        { x: centerX, y: centerY * 0.5 },           // Top center
        { x: centerX * 0.5, y: centerY * 1.5 },     // Bottom left
        { x: centerX * 1.5, y: centerY * 1.5 }      // Bottom right
      ];
      
      for (let i = 0; i < lightPositions.length; i++) {
        const pos = lightPositions[i];
        
        try {
          await canvas.scene.createEmbeddedDocuments("AmbientLight", [{
            x: pos.x,
            y: pos.y,
            config: {
              dim: radius,
              bright: 0,
              color: "#ffffff",
              alpha: 0.1,  // Very low base brightness
              animation: {
                type: "soundPulse",
                speed: 5,
                intensity: 5
              },
              walls: false  // Not constrained by walls
            },
            flags: {
              clockweather: {
                isWeatherEffect: true,
                effectType: "lightning"
              }
            }
          }]);
          
          console.log(`Clock & Weather | Created lightning light ${i + 1} at (${pos.x}, ${pos.y})`);
        } catch (error) {
          console.error(`Clock & Weather | Error creating light ${i + 1}:`, error);
        }
      }
      
      // Create 3 ambient sound sources at the same positions
      for (let i = 0; i < lightPositions.length; i++) {
        const pos = lightPositions[i];
        
        try {
          await canvas.scene.createEmbeddedDocuments("AmbientSound", [{
            x: pos.x,
            y: pos.y,
            radius: radius,
            path: soundFile,
            volume: 1,
            walls: false,  // Not constrained by walls
            flags: {
              clockweather: {
                isWeatherEffect: true,
                effectType: "thunder_sound"
              }
            }
          }]);
          
          console.log(`Clock & Weather | Created thunder sound ${i + 1} at (${pos.x}, ${pos.y})`);
        } catch (error) {
          console.error(`Clock & Weather | Error creating sound ${i + 1}:`, error);
        }
      }
      
    } else {
      // Just create a single ambient sound in the center
      try {
        await canvas.scene.createEmbeddedDocuments("AmbientSound", [{
          x: centerX,
          y: centerY,
          radius: radius,
          path: soundFile,
          volume: 0.5,
          walls: false,  // Not constrained by walls
          flags: {
            clockweather: {
              isWeatherEffect: true,
              effectType: "ambient_sound"
            }
          }
        }]);
        
        console.log(`Clock & Weather | Created ambient sound at center (${centerX}, ${centerY})`);
      } catch (error) {
        console.error("Clock & Weather | Error creating ambient sound:", error);
      }
    }
  }

  async clearAmbientWeatherEffects() {
    if (!canvas.scene) return;
    
    console.log("Clock & Weather | Clearing ambient weather effects...");
    
    // Find and delete all lights created by clockweather
    const weatherLights = canvas.scene.lights.filter(light => 
      light.flags?.clockweather?.isWeatherEffect === true
    );
    
    if (weatherLights.length > 0) {
      const lightIds = weatherLights.map(l => l.id);
      await canvas.scene.deleteEmbeddedDocuments("AmbientLight", lightIds);
      console.log(`Clock & Weather | Removed ${lightIds.length} weather lights`);
    }
    
    // Find and delete all sounds created by clockweather
    const weatherSounds = canvas.scene.sounds.filter(sound =>
      sound.flags?.clockweather?.isWeatherEffect === true
    );
    
    if (weatherSounds.length > 0) {
      const soundIds = weatherSounds.map(s => s.id);
      await canvas.scene.deleteEmbeddedDocuments("AmbientSound", soundIds);
      console.log(`Clock & Weather | Removed ${soundIds.length} weather sounds`);
    }
  }

  startAmbientLightning() {
    // Stop existing lightning interval
    this.stopAmbientLightning();
    
    console.log("Clock & Weather | Starting ambient lightning effects");
    
    // Random lightning flashes every 5-15 seconds
    this._lightningInterval = setInterval(() => {
      if (!canvas.scene) return;
      
      // Random lightning flash
      const currentDarkness = canvas.scene.darkness;
      const flashDuration = 100 + Math.random() * 200; // 100-300ms flash
      
      // Flash to brighter
      canvas.scene.update({ darkness: Math.max(0, currentDarkness - 0.3) });
      
      // Return to normal after flash
      setTimeout(() => {
        canvas.scene.update({ darkness: currentDarkness });
      }, flashDuration);
      
      // Sometimes double flash
      if (Math.random() > 0.7) {
        setTimeout(() => {
          canvas.scene.update({ darkness: Math.max(0, currentDarkness - 0.2) });
          setTimeout(() => {
            canvas.scene.update({ darkness: currentDarkness });
          }, 80);
        }, flashDuration + 200);
      }
      
    }, 5000 + Math.random() * 10000); // Random interval 5-15 seconds
  }

  stopAmbientLightning() {
    if (this._lightningInterval) {
      clearInterval(this._lightningInterval);
      this._lightningInterval = null;
      console.log("Clock & Weather | Stopped ambient lightning effects");
    }
  }

  async updateAmbientSound(weatherData) {
    const weatherCode = weatherData.rawWeatherCode || "";
    const windspeed = weatherData.windspeed;
    let soundFile = null;
    let volume = 0.5;

    // Determine which sound to play based on weather
    if (weatherCode.includes("thunder")) {
      soundFile = "modules/clockweather/sounds/thunderstorm.ogg";
      volume = 0.7;
    } else if (weatherCode.includes("heavy_rain")) {
      soundFile = "modules/clockweather/sounds/heavy_rain.ogg";
      volume = 0.6;
    } else if (weatherCode.includes("rain")) {
      soundFile = "modules/clockweather/sounds/rain.ogg";
      volume = 0.5;
    } else if (windspeed > 15) {
      soundFile = "modules/clockweather/sounds/strong_wind.ogg";
      volume = 0.4;
    } else if (weatherCode.includes("sandstorm") || weatherCode.includes("dust")) {
      soundFile = "modules/clockweather/sounds/sandstorm.ogg";
      volume = 0.5;
    }

    // Stop current sound if it's different
    if (this._currentSound && this._currentSoundFile !== soundFile) {
      this._currentSound.stop();
      this._currentSound = null;
    }

    // Play new sound if needed
    if (soundFile && (!this._currentSound || this._currentSoundFile !== soundFile)) {
      try {
        console.log(`Clock & Weather | Playing ambient sound: ${soundFile}`);
        this._currentSound = await AudioHelper.play({
          src: soundFile,
          volume: volume,
          loop: true
        }, false);
        this._currentSoundFile = soundFile;
      } catch (error) {
        console.warn(`Clock & Weather | Could not play sound ${soundFile}:`, error);
      }
    }

    // Stop sound if weather is calm
    if (!soundFile && this._currentSound) {
      this._currentSound.stop();
      this._currentSound = null;
      this._currentSoundFile = null;
      console.log("Clock & Weather | Stopped ambient sound (calm weather)");
    }
  }

  getWeatherEffects(weatherData) {
    const effects = [];
    const weatherCode = weatherData.rawWeatherCode || weatherData.weatherCode;
    const windspeed = weatherData.windspeed;
    const windDir = weatherData.windDirection || "N";

    console.log("Clock & Weather | Getting effects for weather:", weatherCode, "windspeed:", windspeed, "direction:", windDir);

    // Convert wind direction to angle
    // 0° = West to East (left to right)
    // 90° = South to North (bottom to top)
    // 180° = East to West (right to left)
    // 270° = North to South (top to bottom)
    const directionAngles = {
      "N": 270,    // Blowing from North (top to bottom)
      "NE": 315,   // Blowing from Northeast (top-right to bottom-left)
      "E": 0,      // Blowing from East (right to left) - wraps to 360
      "SE": 45,    // Blowing from Southeast (bottom-right to top-left)
      "S": 90,     // Blowing from South (bottom to top)
      "SW": 135,   // Blowing from Southwest (bottom-left to top-right)
      "W": 180,    // Blowing from West (left to right)
      "NW": 225    // Blowing from Northwest (top-left to bottom-right)
    };
    
    const windAngle = directionAngles[windDir] || 180;

    // Regneffekter
    if (weatherCode.includes("rain")) {
      let density = 0.5;
      let speed = 1.5;
      
      if (weatherCode.includes("heavy")) {
        density = 0.8;
        speed = 2.0;
      } else if (weatherCode.includes("light")) {
        density = 0.3;
        speed = 1.0;
      }
      
      effects.push({
        type: "rain",
        options: { 
          density: density, 
          speed: speed, 
          direction: windAngle 
        }
      });
    }

    // Snöeffekter
    if (weatherCode.includes("snow")) {
      let density = 0.4;
      let speed = 1.0;
      
      if (weatherCode.includes("blizzard")) {
        density = 1.0;
        speed = 2.5;
      } else if (weatherCode.includes("heavy")) {
        density = 0.7;
        speed = 1.5;
      } else if (weatherCode.includes("light")) {
        density = 0.2;
        speed = 0.5;
      }
      
      effects.push({
        type: "snow",
        options: { 
          density: density, 
          speed: speed, 
          direction: windAngle 
        }
      });
    }

    // Dimma
    if (weatherCode.includes("fog") || weatherCode.includes("mist")) {
      effects.push({
        type: "fog",
        options: { 
          density: 0.5, 
          speed: 0.3 
        }
      });
    }

    // Åska - använd lightning om FXMaster har det
    if (weatherCode.includes("thunder")) {
      // FXMaster kanske inte har lightning, prova att lägga till regn med högre intensitet
      effects.push({
        type: "rain",
        options: { 
          density: 0.9, 
          speed: 2.5, 
          direction: windAngle 
        }
      });
      
      // Försök med lightning om det finns
      // Note: Vissa versioner av FXMaster kanske inte har lightning
      // effects.push({
      //   type: "lightning",
      //   options: { frequency: 5000, brightness: 0.8 }
      // });
    }

    // Vind - löv om varmt väder
    if (windspeed > 12 && weatherData.temp > 5) {
      // FXMaster kanske inte har leaves, men vi kan testa
      // effects.push({
      //   type: "leaves",
      //   options: { density: 0.3, speed: 1.5, direction: windAngle }
      // });
    }

    return effects;
  }
}

// Registrera inställningar
Hooks.once("init", () => {
  window.ClockWeatherApp = ClockWeatherApp;
  
  game.settings.register("clockweather", "currentDateTime", {
    name: "Current Date and Time",
    scope: "world",
    config: false,
    type: Object,
    default: { date: "2014-06-14", time: "00:00" }
  });

  game.settings.register("clockweather", "controlAmbientLight", {
    name: "CLOCKWEATHER.Settings.ControlLight",
    hint: "CLOCKWEATHER.Settings.ControlLightHint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false
  });

  game.settings.register("clockweather", "autoFXMaster", {
    name: "CLOCKWEATHER.Settings.AutoFXMaster",
    hint: "CLOCKWEATHER.Settings.AutoFXMasterHint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
    requiresReload: false
  });

  game.settings.register("clockweather", "enableAmbientSound", {
    name: "CLOCKWEATHER.Settings.EnableSound",
    hint: "CLOCKWEATHER.Settings.EnableSoundHint",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
    requiresReload: false
  });

  game.settings.register("clockweather", "soundEnvironment", {
    name: "CLOCKWEATHER.Settings.SoundEnvironment",
    hint: "CLOCKWEATHER.Settings.SoundEnvironmentHint",
    scope: "world",
    config: true,
    type: String,
    choices: {
      "land": "CLOCKWEATHER.Settings.OnLand",
      "sea": "CLOCKWEATHER.Settings.AtSea"
    },
    default: "land",
    requiresReload: false
  });

  game.settings.register("clockweather", "weatherFile", {
    name: "CLOCKWEATHER.Settings.WeatherFile",
    hint: "CLOCKWEATHER.Settings.WeatherFileHint",
    scope: "world",
    config: true,
    type: String,
    filePicker: "data",
    default: "modules/clockweather/weatherdata/weather.json",
    onChange: async value => {
      await loadWeatherData(value);
    }
  });

  game.settings.register("clockweather", "weatherData", {
    name: "Weather Data Cache",
    scope: "world",
    config: false,
    type: Object,
    default: {}
  });

  game.settings.register("clockweather", "altitude", {
    name: "CLOCKWEATHER.Settings.Altitude",
    hint: "CLOCKWEATHER.Settings.AltitudeHint",
    scope: "world",
    config: true,
    type: Number,
    default: 0,
    range: {
      min: 0,
      max: 3900,
      step: 150
    }
  });

  console.log("Clock & Weather | Module initialized");
});

// Ladda väderdata
async function loadWeatherData(filepath) {
  try {
    console.log("Clock & Weather | Attempting to load weather data from:", filepath);
    
    let fullPath = filepath;
    if (!filepath.startsWith("modules/") && !filepath.startsWith("worlds/")) {
      fullPath = `modules/clockweather/weatherdata/${filepath}`;
    }
    
    console.log("Clock & Weather | Full path:", fullPath);
    
    const response = await fetch(fullPath);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    await game.settings.set("clockweather", "weatherData", data);
    console.log("Clock & Weather | Weather data loaded successfully from:", fullPath);
    ui.notifications.info(game.i18n.localize("CLOCKWEATHER.WeatherLoaded"));
  } catch (error) {
    console.error("Clock & Weather | Error loading weather data:", error);
    ui.notifications.error(`${game.i18n.localize("CLOCKWEATHER.ErrorLoadingWeather")}: ${error.message}`);
  }
}

// Lägg till knapp i Token Controls
Hooks.on("getSceneControlButtons", controls => {
  controls.tokens.tools.clockWeather = {
    name: "clockWeather",
    title: game.i18n.localize("CLOCKWEATHER.Title"),
    icon: "fas fa-cloud-sun",
    order: Object.keys(controls.tokens.tools).length,
    button: true,
    visible: game.user.isGM,
    onClick: () => {
      const existing = foundry.applications.instances.get("clockweather-app");
      if (existing) existing.close();
      else new ClockWeatherApp().render({force: true});
    }
  };
});

// Ladda väderdata när ready
Hooks.once("ready", async () => {
  const weatherFile = game.settings.get("clockweather", "weatherFile");
  await loadWeatherData(weatherFile);
  
  // Log FXMaster status
  if (game.modules.get("fxmaster")?.active) {
    console.log("Clock & Weather | FXMaster detected and active");
    console.log("Clock & Weather | FXMASTER API:", window.FXMASTER);
  }
  
  // Applicera FXMaster om aktiverat och modulen finns
  if (game.settings.get("clockweather", "autoFXMaster") && game.modules.get("fxmaster")?.active) {
    const app = new ClockWeatherApp();
    await app.updateFXMaster();
  }
  
  console.log("Clock & Weather | Ready");
});